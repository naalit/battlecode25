offx = [2, 1, 1, 1, 0, 0, 0, 0, 0, -1, -1, -1, -2]
offy = [0, -1, 0, 1, -2, -1, 0, 1, 2, -1, 0, 1, 0]

# the idea:
# list all the locations *in python* (69 total)
# then for each one, do senseMapInfo and such
# and we KNOW which slots in `locs` to add to
# this'll be a lot more code...
# but it should be okay
# we're trying to have this be self-contained this time:

print("""
// GENERATED BY microgen.py
package immanentize;

import battlecode.common.*;
import static immanentize.Micro.*;
import static immanentize.RobotPlayer.*;

public class MicroHelper {

""")
print("  static void processSplasherLocsGenHelper(MapLocation center, MicroLoc[] ulocs) throws GameActionException {")
print("    MapLocation loc;")
print("    var locs = new double[7][7];\n")

qoffx, qoffy = [-1, -1, -1, 0, 0, 0, 1, 1, 1], [-1, 0, 1, -1, 0, 1, -1, 0, 1]

for i in range(-4, 5):
    for j in range(-4, 5):
        if i*i + j*j > 20:
            continue
        print(f"    loc = center.translate({i}, {j});")
        print( "    if (rc.onTheMap(loc)) {")

        print( "      var tile = rc.senseMapInfo(loc);")
        print( "      if (tile.isPassable()) {")
        print( "        if (tile.getPaint() == PaintType.EMPTY) {")

        for k in range(len(offx)):
            ax = i + offx[k]
            ay = j + offy[k]
            #if ax > 0 and ay > 0 and ax < 7 and ay < 7:
            if ax*ax + ay*ay <= 10:
                print(f"          locs[{ax+3}][{ay+3}] += MAP_PAINT_VALUE;")

        print( "        } else if (tile.getPaint().isEnemy()) {")

        for k in range(len(qoffx)):
            ax = i + qoffx[k]
            ay = j + qoffy[k]
            #if ax > 0 and ay > 0 and ax < 7 and ay < 7:
            if ax*ax + ay*ay <= 10:
                print(f"          locs[{ax+3}][{ay+3}] += 2 * MAP_PAINT_VALUE;")

        print( "        } else if (tile.getPaint() == PaintType.ALLY_SECONDARY) {")

        # Penalize painting over secondary friendly paint
        # (Would specifically penalize painting over resource patterns but that's too much bytecode)
        for k in range(len(offx)):
            ax = i + offx[k]
            ay = j + offy[k]
            #if ax > 0 and ay > 0 and ax < 7 and ay < 7:
            if ax*ax + ay*ay <= 10:
                print(f"          locs[{ax+3}][{ay+3}] -= 1.5 * MAP_PAINT_VALUE;")

        print( "        }")
        print( "      }")

        print( "    }")

print("\n")
# now attacks
print("    for (var unit : nearbyEnemies) {")
print("      if (unit.type.isRobotType()) continue;")
print("      var d = (double) Math.min(UnitType.SPLASHER.aoeAttackStrength, unit.health) / unit.type.health;")
print("      var x = unit.location.x - center.x;")
print("      var y = unit.location.y - center.y;")
print("      int ax, ay;")
prevx = -5
for i in range(len(offx)):
    px, py = "ax", "ay"
    if offx[i] == 0:
        px = "x"
    elif prevx != offx[i]:
        print(f"      ax = x + {offx[i]};")
        prevx = offx[i]
    if offy[i] == 0:
        py = "y"
    else:
        print(f"      ay = y + {offy[i]};")
    print(f"      if ({px}*{px} + {py}*{py} <= 10) {{")
    print(f"        locs[{px}+3][{py}+3] += d;")
    print( "      }")
print("    }")

print("\n")
# now collect the best target for each move location
print("    var moveLocs = new MapLocation[9];");
print("    var moveScores = new double[9];");
print("    var cost = UnitType.SPLASHER.attackCost * FREE_PAINT_VALUE;")

i = 0
for x in range(-1, 2):
    for y in range(-1, 2):
        print(f"\n    loc = center.translate({x}, {y});")
        print( "    if (rc.onTheMap(loc) && rc.senseMapInfo(loc).isPassable() && !rc.canSenseRobotAtLocation(loc)) {")
        print( "      var mscore = cost;")
        print( "      MapLocation mloc = null;")

        for k in range(len(offx)):
            ax = x + offx[k]
            ay = y + offy[k]
            if ax*ax + ay*ay <= 10:
                print(f"      if (locs[{ax+3}][{ay+3}] > mscore) {{")
                print(f"        mscore = locs[{ax+3}][{ay+3}];")
                print(f"        mloc = center.translate({ax}, {ay});")
                print( "      }")

        print(f"      moveScores[{i}] = mscore - cost;")
        print(f"      moveLocs[{i}] = mloc;")

        print( "    }")
        i += 1

print("\n")
print("    for (var uloc : ulocs) {")
print("      var dx = uloc.loc.x - center.x;")
print("      var dy = uloc.loc.y - center.y;")
print("      var idx = (dy + 1) + (dx + 1) * 3;")
print("      uloc.attack = new Attack(moveScores[idx], moveLocs[idx], null);")
print("    }")

print("  }")
print("}")
